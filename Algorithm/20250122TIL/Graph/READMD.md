# 20250122 TIL
Today I Learned


* BFS/DFS

### BFS
````python3
from collections import deque

graph = {
    'A': ['B', 'D', 'E'],
    'B': ['A', 'C', 'D'],
    'C': ['B'],
    'D': ['A', 'B'],
    'E': ['A']
}

def bfs(graph, start):
    visited = [start] # 맨처음 노드는 방문으로 취급
    queue = deque(start) # 처음 노드를 큐에 넣고 시작
    while queue: # queue가 존재 할 때 까지 순회
        current = queue.popleft() # FIFO에 의해 현재 탐색할 노드를 꺼내옴
        for next in graph[current]: # 현재 노드에서 인접 노드가 있는지 판별
            if next not in visited: # 인접 노드가 방문한적 있는지 판별
                visited.append(next)
                queue.append(next)
    return visited


print(bfs(graph, 'A'))
````
1. 시작 노드: 'A'
   * 방문 리스트: ['A']
   * 큐: ['A']

2. 노드 'A' 탐색:
   * 인접 노드: 'B', 'D', 'E' 
   * 방문 리스트: ['A', 'B', 'D', 'E']
   * 큐: ['B', 'D', 'E']

3. 노드 'B' 탐색:
   * 인접 노드: 'A', 'C', 'D'
   * 'A'은 이미 방문
   * 'C' 방문 
   * 방문 리스트: ['A', 'B', 'D', 'E', 'C']
   * 큐: ['D', 'E', 'C']

4. 노드 'D' 탐색:
   * 인접 노드: 'A', 'B' 
   * 두 노드 모두 이미 방문 
   * 방문 리스트: ['A', 'B', 'D', 'E', 'C']
   * 큐: ['E', 'C']

5. 노드 'E' 탐색:
   * 인접 노드: 'A'
   * 'A'은 이미 방문
   * 방문 리스트: ['A', 'B', 'D', 'E', 'C']
   * 큐: ['C']

6. 노드 'C' 탐색:
   * 인접 노드: 'B'
   * 'B'는 이미 방문
   * 방문 리스트: ['A', 'B', 'D', 'E', 'C']
   * 큐: []

7. 종료:
   * 큐가 비어있으므로 BFS 탐색 종료
   * 최종 방문 순서: ['A', 'B', 'D', 'E', 'C']


````scss
    A
  / | \
 B  D  E
 | /   
 C
````
1. 시작: 'A' 방문 
2. 레벨 1: 'A'의 인접 노드 'B', 'D', 'E' 방문 
3. 레벨 2: 'B'의 인접 노드 'C' 방문 ('A'과 'D'는 이미 방문)
4. 레벨 3: 'D'와 'E'의 인접 노드는 이미 방문 ('A', 'B')
5. 레벨 4: 'C'의 인접 노드 'B'는 이미 방문


* 큐의 역할:
  * BFS는 큐를 사용하여 레벨 단위로 노드를 탐색합니다.
  * 먼저 들어온 노드가 먼저 나가므로 FIFO(First-In-First-Out) 방식으로 동작합니다.

* 방문 리스트 visited:
  * 방문한 노드를 기록하여 중복 방문을 방지합니다. 
  * BFS에서는 방문한 노드를 큐에 넣기 전에 체크하여 효율성을 높입니다.

* 시간 복잡도:
  * BFS의 시간 복잡도는 O(V + E)입니다. 
  * V: 노드의 수 
  * E: 간선의 수

* BFS의 활용 사례:
  * 최단 경로 찾기 
  * 그래프의 연결 요소 탐색 
  * 네트워크 브로드캐스트



----


### DFS
````python3
graph = {
    'A': ['B', 'D', 'E'],
    'B': ['A', 'C', 'D'],
    'C': ['B'],
    'D': ['A', 'B'],
    'E': ['A']
}

visited = []

def dfs(current):
    visited.append(current) # 현재 노드를 방문 표시
    for next in graph[current]: # 현재 노드의 인접 노드를 반복문을 통해 확인
        if next not in visited: # 인접 노드가 방문 됐는지 판별
            dfs(next) # 방문되지 않았다면 재귀를 통해 해당 노드의 연결된 노드를 또 확인 -> 깊게 들어감

    return visited


print(dfs('A'))
````
1. 시작 노드: 'A'
    * 방문 리스트: ['A']

2. 노드 'A' 탐색:
   * 인접 노드: 'B', 'D', 'E'
   * 'B' 방문 후 재귀 호출

3. 노드 'B' 탐색:
   * 인접 노드: 'A', 'C', 'D'
   * 'A'는 이미 방문, 'C' 방문 후 재귀 호출

4. 노드 'C' 탐색:
   * 인접 노드: 'B'
   * 'B'는 이미 방문
   * 'C' 탐색 종료, 'B' 탐색 계속

5. 노드 'B' 탐색 계속:
   * 'D' 방문 후 재귀 호출

6. 노드 'D' 탐색:
   * 인접 노드: 'A', 'B'
   * 둘 다 이미 방문
   * 'D' 탐색 종료, 'B' 탐색 종료, 'A' 탐색 계속

7. 노드 'A' 탐색 계속:
   * 'D'는 이미 방문, 'E' 방문 후 재귀 호출

8. 노드 'E' 탐색:
   * 인접 노드: 'A'
   * 'A'는 이미 방문
   * 'E' 탐색 종료, 'A' 탐색 종료

9. 종료:
   * 모든 노드가 방문되었으므로 DFS 탐색 종료
   * 최종 방문 순서: ['A', 'B', 'C', 'D', 'E']


````scss
    A
  / | \
 B  D  E
 | /   
 C
````
1. 시작: 'A' 방문 
2. 깊게 들어감: 'A' → 'B' 
3. 더 깊게 들어감: 'B' → 'C' 
4. 더 이상 갈 곳 없어서 되돌아감: 'C' → 'B' 
5. 다른 방향으로 이동: 'B' → 'D' 
6. 더 이상 갈 곳 없어서 되돌아감: 'D' → 'B' → 'A' 
7. 다른 방향으로 이동: 'A' → 'E' 
8. 더 이상 갈 곳 없어서 탐색 종료



* DFS 탐색의 특징:
  * 깊이 우선: 가능한 한 깊게 노드를 탐색하다가 더 이상 갈 곳이 없으면 이전 노드로 되돌아갑니다.
  * 재귀적 구현: 재귀를 통해 간단하게 구현할 수 있습니다.
  * 방문 리스트: 중복 방문을 방지하기 위해 방문한 노드를 기록합니다.

* 시간 복잡도:
  * BFS의 시간 복잡도는 O(V + E)입니다.
  * V: 노드의 수
  * E: 간선의 수

* DFS의 활용 사례:
  * 그래프의 연결 요소 찾기
  * 미로 찾기 문제
  * 트리의 순회 (전위, 중위, 후위 순회)