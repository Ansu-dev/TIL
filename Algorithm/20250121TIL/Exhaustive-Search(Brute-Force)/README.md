# 20250121 TIL
Today I Learned

* 완전 탐색(Brute-Force)

정답이 될 가능성이 있는 모든 후보를
체계적(반복문, 재귀, 비트마스크 등)으로 확인하는 것

* 반복문, 재귀, 비트마스크으로 활용하여 구현

````text
💡 어떤 문제에 완전 탐색을 적용할 지?

Q. 리스트[4,9,7,5,1]에 두 개의 숫자를 더해서 14가 될 수 있는지?(중복x)
반복을 사용해 풀 수 있음(2중 for문)

Q. 리스트[4, 9, 7, 5, 1]에 세 개의 숫자를 더해서 17가 될 수 있나요?(중복x)
3개의 숫자니 3중 for문? -> 재귀를 통해 중첩 for문을 줄임

- 모든 후보를 탐색하며, 정답이 될 가능성이 있는 후보지를 모두 비교해보기
````
----

### 백트래킹
solution이 될 가능성이 없이 후보군은 더 이상 탐색하지 않고 탐색
````text
Q. word search 가로 또는 세로로 이어서 "CAT"이라는 글자를 만들어 주세요.
C로 시작할 수 있는 단어를 찾은 후 C를 기준으로 가로 세로로 CAT이 가능한지 탐색

Q. 핸드폰 키패드에서 '4 5 6'을 이용해서 'kor'를 작성할 수 있나요?
4번을 선택하면 j k i
5번을 선택하면 m n o
6번을 선택하면 p q r

총 27가지의 경우의 수를 통해 kor이 되는지 확인
````
* 완전 탐색이지만 후보군이 정답이 될 가능이 없는 경우가 있다면 백트래킹을 사용
* two sum같은 경우 후보군을 끝까지 탐색하지 않고선 정답인지 알수 없으므로 백트래킹이 비효율

----

### DP
큰 문제를 작은 문제들로 나누어 해결한 후,
그 결과를 저장하여 중복 계산을 줄이는 최적화 기법
````text
Q. 출발지에서 도착지까지 최단거리로 도달하는 모든 경우의 수는?
- 0,1 ~ 2,2까지 좌표를 모든 경우의 수
- 상태트리를 통해 모든 경우의 수를 살펴봄
````
* 모든 경우의 수 -> 완전 탐색을 생각 (중간에 멈추는 것이 아닌 모든 후보군을 봐야함)
* DP를 통해 중복을 제거하며 경우의 수를 줄여 최적화

----

### 순열
````text
Q. nums=[1,2,3,4]로 만들 수 있는 모든 순열을 반환
````
----

### 조합
````text
Q. nums=[1,2,3,4]에서 두 개의 원소를 선택해 만들 수 있는 모든 조합을 반환
조합에서는 어떤 원소가 있는 것이 중요하므로 1,2 = 2,1은 같은 경우다.
````
----

### 부분 집합

----

### two sum